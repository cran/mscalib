image.mlist<-function(x,what="",col=terrain.colors(100),...)
  {
    ##t Display a Color Image
    ##- Creates a grid of colored or gray-scale rectangles with colors
    ##- corresponding to the values in 'z'.  This can be used to display
    ##- three-dimensional or spatial data aka "images". This is a generic
    ##- function.
    ##+ x : object of class mlist. (e.g: caliblist or massvectorlist)
    ##+ what : what value to display on the image.
    ##+ col : a list of colors such as that generated by 'rainbow', 'heat.colors', 'topo.colors', 'terrain.colors' or similar functions.
    ##e data(mvl)
    ##e image(mvl,what="lengthmv")
    cal<-x
    rm(x)
    if(length(cal)==0){
      warning("List has length 0")
      return()
    }
    res <- as.matrix(cal)
    if(! what %in% colnames(res))
      stop("Only following fields can be shown for ", class(cal)[1]," : \n", join(colnames(res),sep=" "),"\n pass one to the what paramter.")
    nam <- mget(cal,"tcoor")
    if(!is.null(names(nam$coorX)) & !is.null(names(nam$coorY)))
      {
        X <- nam$coorX[unique(names(nam$coorX))]
        Y <- nam$coorY[unique(names(nam$coorY))]
        XX <- 1:max(X)
        names(XX)<-rep("",max(X))
        names(XX)[X]<-names(X)
        X<-XX
        YY <- 1:max(Y)
        names(YY)<-rep("",max(Y))
        names(YY)[Y]<-names(Y)
        Y<-YY
      }
    else
      {
        X <- unique(nam$coorX)
        Y <- unique(nam$coorY)
      }
    hello <- matrix(NA,max(X),max(Y))
   


    for(z in 1:length(cal))
      {
        hello[ nam$coorX[z] , nam$coorY[z] ] <- res[z,what]
      }

    if(!is.null(names(X)) & !is.null(names(Y)))
       {
         rownames(hello) <- names(X)
         colnames(hello) <- names(Y)
       }

    par(bg="gray")
    tmar<-par()$mar
    nf <- layout(matrix(c(1,2),1,2),widths=c(5,1), TRUE)
    par(mar=c(3,3,2,0.5))
 
    image(t(hello) , main=what,xaxs="i",yaxs="i",axes=FALSE,col=col,...)
    if((length(Y)-1)>0)
      {
        axis( 1 , at=seq(0,1,1/(length(Y)-1)) , labels=names(sort(Y)))
      }
    else
      {
         axis(1,at=0.5,labels=names(Y))
      }
    if((length(X)-1)>0)
      {
        axis( 2 , at=seq(0,1,1/(length(X)-1)) , labels=names(sort(X)))
      }
    else
      {
        axis(2,at=6,labels=names(X))
      }
    tres<-na.omit(c(hello))
    if(min(tres)!=max(tres))
      {
        scale<-seq(min(tres),max(tres),(max(tres)-min(tres))/9)
      }
    else
      {
        scale<-rep(min(tres),10)
      }
    scale<-matrix(scale,nrow=1)
    par(mar=c(3,0,2,0.5))
    image(1,1:10,scale,axes=FALSE,xlab="",ylab="",col=col)
    scalet<-format(scale,digits=1)
    for(x in 1:length(scalet))
      {
        text(0.5,x,scalet[x])
      }
    par(mar=tmar)
    layout(matrix(1))
    invisible(t(hello))
  }


mget.mlist<-function(object,attrn,...)
  {
    ##t Field Access
    ##- Acces fields in object of class myobj
    ##+ object : object of class  mlist
    ##+ attrn : name of field (Attribute)
    ##e data(mvl)
    ##e mget(mvl)
    ##e mget(mvl,"info")
    ##e mget(mvl,"tcoor")
    if(missing(attrn))
      return(attr(object,"allow"))
    if(attrn %in% "tcoor")
      {
        res <- NULL
        nres<-NULL
        for(x in object)
          {
            res <- rbind( res , mget(x,"tcoor") )
            nres <- rbind( nres,names(mget(x,"tcoor")) )
          }
        coorX <- res[,1]
        names(coorX) <- nres[,1]
        coorY<-res[,2]
        names(coorY)<-nres[,2]
        return(list(coorX=coorX,coorY=coorY))
      }
    else
      NextMethod("mget")
  }

experiment.mlist<-function(object,experiment,...)
  {
    ##t Info Acces
    ##- Access to the experiment field of the mlist. Can be used for setting or getting the experiment field.
    ##a info.mlist
    ##+ object : object of class mlist
    ##+ experiment : New experiment name. If not missing function returns massvector with new info field content.
    ##e data(mvl)
    ##e experiment(mvl)
    ##e mvl<-experiment(mvl,"newname")
    if(missing(experiment))
      return(mget(object,"experiment"))
    else
      {
        setParms(object)<-list(experiment=experiment)
      }
    object
  }

info.mlist<-experiment.mlist

subset.list <- function(x,subset,...)
  {
    ##t Subset mlist
    ##- Return subsets of list elements which meet conditions.
    ##+ x : object of class mlist
    ##+ subset : logical expression.
    ##e data(mvl)
    ##e mvl<-subset(mvl,lengthmv>30)
    
    
    u <- as.data.frame(x)
    if (missing(subset))
      {
        r <- TRUE
        cat("For subsetting use comparison on : \n", join(names(u),sep=" ")  ,"\n")
        return()
      }
    else {
        e <- substitute(subset)
        r <- eval(e, u, parent.frame())
        r <- r & !is.na(r)
    }
    vars <- TRUE
    u <- u[r, vars, drop = FALSE]
    x[as.character(u$info)]
}
